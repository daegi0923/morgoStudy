# Adv 07 스노우맨

문제링크 제공 불가


### 분류

다익스트라, BFS

### 제출 일자

2024년 2월 29일

### 접근법
1. 다익스트라 알고리즘 사용
1. 현재 위치에서 양 옆으로 갈 수 있다면 현 위치의 비용과 같은 비용으로 갱신
1. 위, 아래로 이동할 수 있다면 현 위치의 비용과 점프하는 비용을 비교하여 더 큰 값으로 갱신
1. 갱신하였다면 그 좌표를 큐에 넣어서 탐색(BFS)
1. 도착점의 최소비용 갱신, 출력

```python
import heapq



N, M = map(int, input().split())
MAP = [list(map(int, input().split())) for _ in range(N)]
MAP_t = list(zip(*MAP[::-1]))
# print(MAP_t)
ans = float('inf')
di = [0, 0]
dj = [1, -1]
start = [(row_num,row.index(2)) for row_num, row in enumerate(MAP) if 2 in row][0]
end = [(row_num,row.index(3)) for row_num, row in enumerate(MAP) if 3 in row][0]
cost_mat = [[float('inf')]*M for _ in range(N)]
si, sj = start
ei, ej = end
pq = [[0, si, sj]]
cost_mat[si][sj] = 0
while pq:

    cc, ci, cj = heapq.heappop(pq)
    # if ci == ei and cj == ej:
    #     break
    nexts = []
    for d in range(2):
        nj = cj+dj[d]
        if 0<=nj<M and MAP[ci][nj]:
            if cost_mat[ci][nj] > cost_mat[ci][cj]:
                heapq.heappush(pq,[cost_mat[ci][cj], ci, nj])
                cost_mat[ci][nj] = cost_mat[ci][cj]

    for d in range(N):
        ni = ci + d
        if 0<= ni < N and MAP[ni][cj] and cost_mat[ni][cj] > max(cc,d):
            heapq.heappush(pq, [max(cc,d), ni, cj])
            cost_mat[ni][cj] = max(cc,d)
            break
    for d in range(N):
        ni = ci - d
        if 0<= ni < N and MAP[ni][cj] and cost_mat[ni][cj] > max(cc,d):
            heapq.heappush(pq, [max(d, cc), ni, cj])
            cost_mat[ni][cj] = max(d, cc)
            break
# [print(*row) for row in cost_mat]
print(cost_mat[ei][ej])
```