# MIN_IM_두개의직사각형

참고문제: SWEA 색칠하기, [BOJ 직사각형](https://www.acmicpc.net/problem/2527) 


### 분류
구현



### 접근법
1. 1001 by 1001의 0으로 채운 MAP이라는 이차원 리스트를 만든다. 좌표의 값과 일치하는 인덱스 값에 숫자를 채워넣기 위함이다.
2. 두개의 직사각형을 각각 순회하면서 모든 좌표에 1을 더하고 테두리에는 1을 한번 더 더한다. 순회를 끝냈을 때 MAP의 값에 4는 테두리 끼리 만났다는 뜻이고, 3은 테두리와 격자 내부가 만났다는 뜻이다. 
3. 면, 선, 점, 해당x 4가지 케이스에 대한 분류를 위해 cnt라는 1차원 리스트를 만들고 MAP의 좌표에 해당하는 값을 cnt의 인덱스값에 더해가며 그 갯수를 센다.
4. cnt의 인덱스 3, 4를 위주로 해석하여 결과를 도출한다.

### Code
```python
T = int(input())

for t in range(T):
    cnt = [0] * 5
    MAP = [[0] * 1001 for _ in range(1001)]
    ans = 0

    for i in range(1,3):
        x1, y1, x2, y2 = map(int, input().split())
        # print(f'{i}번째 사각형의 좌표',x1,y1,x2,y2)
        for j in range(y1, y2 + 1):  # +1 을해줘야 y2까지 계산가능
            for k in range(x1, x2 + 1):  # +1 을해줘야 y2까지 계산가능
                # 사각형의 테두리
                if j == y1 or j == y2 or k == x1 or k == x2:  # j는 언제시작되는가?y1 끝점은?y2
                    MAP[j][k] += 1
                # 격자의 내부 부분 좌표값에 1 더해주고, cnt 리스트에서 해당 숫자의 횟수 증가
                MAP[j][k] += 1
                # print(MAP[j][k])
                cnt[MAP[j][k]] += 1
                # print(cnt)

    # cnt[1]: 격자의 내부가 겹치는 부분이 없을 때
    # cnt[2]: 격자의 테두리가 겹치는 부분이 없을 때 / 격자의 내부가 겹칠 때 / 사각형이 완전히 겹칠 때, 내부
    # 1, 2 는 유효한 정보가 부족함. 3, 4가 결정적인 정보를 내포함.
    # cnt[3]: 한 사각형의 테두리와 한 사각형의 내부가 겹칠 때: 면 / 0일 때: 선(완전히 겹침) or 해당x
    # cnt[4]: ★★1일 때: 점★★ / 사각형이 완전히 겹칠 때 테두리: 선
    # ☆☆cnt[3], cnt[4]가 0일 때: 해당x☆☆
    if cnt[4] == 1:
        ans = 3  # 점
    elif cnt[4] > 1 and cnt[3] > 0:
        ans = 1  # 면
    elif cnt[4] > 1:
        ans = 2  # 선
    else:
        ans = 4  # 해당x

    print(f'#{t+1} {ans}')
```